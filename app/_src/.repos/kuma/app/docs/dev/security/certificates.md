---
title: Secure access across Kuma components
---

This page explains how secure access is provided across a {{site.mesh_product_name}} deployment:

- [security between the data plane proxies and the {{site.mesh_product_name}} control plane](#data-plane-proxy-to-control-plane-communication)
- [security between the user and the {{site.mesh_product_name}} control plane](#user-to-control-plane-communication)
- [security between the {{site.mesh_product_name}} control planes (Multizone)](#control-plane-to-control-plane-multizone)

{{site.mesh_product_name}} stores autogenerated certificates and other files in a working directory. The default value for this
directory is `$HOME/.kuma`. You can change the working directory by setting the `KUMA_GENERAL_WORK_DIR` environment variable.

{% tip %}
This section is not to be confused with the [mTLS policy](/docs/{{ page.version }}/policies/mutual-tls/) that we can apply to a [Mesh](/docs/{{ page.version }}/policies/mesh/) to secure service-to-service traffic.
{% endtip %}

## Data plane proxy to control plane communication

A data plane proxy connects to the control plane for its configuration, including mTLS certificates described in the following sections.

### Encrypted communication

Because the data plane proxy and the control plane exchange sensitive information, the communication needs to be encrypted by TLS.
By default, the control plane's server that is consumed by the data plane proxy is secured by TLS with autogenerated certificates.

It is recommended that the data plane proxy verifies the identity of the control plane. To do so, data plane proxies need to obtain the CA that was used to generate the certificate by which the control plane's server is secured.
Note, this CA is not the same CA for service-to-service communication.

**To override autogenerated certificates**

{% tip %}
If overridden, {{site.mesh_product_name}} uses the certificates to protect not only [data plane proxy to control plane](#data-plane-proxy-to-control-plane-communication) traffic
but also [user to control plane](#user-to-control-plane-communication) traffic
and [control plane to control plane](#control-plane-to-control-plane-multizone) traffic.
{% endtip %}

1) Prepare certificates

Generate a TLS pair with a PKI of your choice and store it in PEM-encoded format in `/tmp/tls.crt`, `/tmp/tls.key`. 
Store the CA that was used to sign this pair in `/tmp/ca.crt`.

We can also use `kumactl` to generate self-signed certs:
```sh
kumactl generate tls-certificate \
  --type=server \
  --hostname=<KUMA_CP_DNS_NAME> \
  --cert-file=/tmp/tls.crt \
  --key-file=/tmp/tls.key
```

Since "tls.crt" is a self-signed cert, it is also a CA:
```sh
cp /tmp/tls.crt /tmp/ca.crt
```

2) Configure the control plane with generated certs:

{% tabs control-plane useUrlFragment=false %}
{% tab control-plane Kubernetes (kumactl) %}
Create a secret in the namespace where the control plane is installed:
```sh
kubectl create secret generic general-tls-certs -n <namespace> \
  --from-file=tls.crt=/tmp/tls.crt \
  --from-file=tls.key=/tmp/tls.key \
  --from-file=ca.crt=/tmp/ca.crt
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
kumactl install control-plane \
  --tls-general-secret=general-tls-certs \
  --tls-general-ca-bundle=$(cat /tmp/ca.crt | base64)
```

The data plane proxy Injector in the control plane automatically provides the CA to the {{site.mesh_product_name}} DP sidecar 
so {{site.mesh_product_name}} DP can confirm the control plane identity.

{% endtab %}
{% tab control-plane Kubernetes (HELM) %}
Create a secret in the namespace where the control plane is installed:
```sh
kubectl create secret generic general-tls-certs -n <namespace> \
  --from-file=tls.crt=/tmp/tls.crt \
  --from-file=tls.key=/tmp/tls.key \
  --from-file=ca.crt=/tmp/ca.crt
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
helm install --create-namespace --namespace <namespace> kuma kuma/kuma \
  --set controlPlane.tls.general.secretName=general-tls-certs \
  --set controlPlane.tls.general.caBundle=$(cat /tmp/ca.crt | base64)
```

The data plane proxy Injector in the control plane automatically provides the CA to the {{site.mesh_product_name}} DP sidecar 
so {{site.mesh_product_name}} DP can confirm the control plane identity.

{% endtab %}
{% tab control-plane Universal %}
Configure the control plane with generated certificates:

```sh
KUMA_GENERAL_TLS_CERT_FILE=/tmp/tls.crt \
  KUMA_GENERAL_TLS_KEY_FILE=/tmp/tls.key \
  kuma-cp run
```

Configure the data plane proxy with CA:

```sh
kuma-dp run \
  --cp-address=https://<KUMA_CP_DNS_NAME>:5678 \
  --ca-cert-file=/tmp/ca.crt \
  --dataplane-file=dp.yaml \
  --dataplane-token-file=/tmp/kuma-dp-redis-1-token
```

You can also provide the CA via environment variable `KUMA_CONTROL_PLANE_CA_CERT`.
{% endtab %}
{% endtabs %}

### Authentication

See [Data plane proxy authentication](/docs/{{ page.version }}/security/dp-auth/) and [Zone proxy authentication](/docs/{{ page.version }}/security/zoneproxy-auth).

## Prometheus to control plane communication

You can enable TLS on the [Monitoring Assignment Discovery Service](/docs/{{ page.version }}/policies/traffic-metrics/).
By default, it uses the same certificate used for CP to DP communication. This is the certificate configured with the `--tls-general` options.
You can enable it by using the `KUMA_MONITORING_ASSIGNMENT_SERVER_TLS_ENABLED=true` environment variable.

{% tabs mads useUrlFragment=false %}
{% tab mads Kubernetes %}
Create a secret in the namespace where the control plane is installed:
```sh
kubectl create secret generic general-tls-certs -n <namespace> \
  --from-file=tls.crt=/tmp/tls.crt \
  --from-file=tls.key=/tmp/tls.key \
  --from-file=ca.crt=/tmp/ca.crt
```

Point to this secret when installing Kuma:
```sh
kumactl install control-plane \
  --tls-general-secret=general-tls-certs \
  --tls-general-ca-bundle=$(cat /tmp/ca.crt | base64) \
  --env-var 'KUMA_MONITORING_ASSIGNMENT_SERVER_TLS_ENABLED=true'
```

{% endtab %}
{% tab mads Universal %}

Configure the control plane with generated certificates:

```sh
KUMA_MONITORING_ASSIGNMENT_SERVER_TLS_CERT_FILE=/tmp/tls.crt \
  KUMA_MONITORING_ASSIGNMENT_SERVER_TLS_KEY_FILE=/tmp/tls.key \
  KUMA_MONITORING_ASSIGNMENT_SERVER_TLS_ENABLED=true \
  kuma-cp run
```

{% endtab %}
{% endtabs %}

Now you can configure Kuma's Prometheus SD with the correct TLS configuration using the [Prometheus docs](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kuma_sd_config).

## User to control plane communication

Users and automation tools can interact with the control plane via the API Server using tools like `curl` or `kumactl`.
API Server is exposed by default on `:5681` on HTTP and `:5682` on HTTPS.

### Encrypted communication

The API Server HTTPS server is secured by default by autogenerated certificates.

**To override autogenerated certificates.**

1) Prepare certificates

Generate TLS pair with a PKI of your choice and store it in PEM-encoded format in `/tmp/tls.crt`, `/tmp/tls.key`. Store the CA that was used to sign this pair in `/tmp/ca.crt`

We can also use `kumactl` to generate self-signed certs:
```sh
kumactl generate tls-certificate \
  --type=server \
  --hostname=<KUMA_CP_DNS_NAME> \
  --cert-file=/tmp/tls.crt \
  --key-file=/tmp/tls.key
```

Since "tls.crt" is a self-signed cert, it is also a CA:
```sh
cp /tmp/tls.crt /tmp/ca.crt
```

2) Configure the control plane with generated certificates
{% tabs configure-control-plane useUrlFragment=false %}
{% tab configure-control-plane Kubernetes (kumactl) %}
Create a secret in the namespace in which the control plane is installed:
```sh
kubectl create secret tls api-server-tls -n <namespace> \
  --cert=/tmp/tls.crt \
  --key=/tmp/tls.key
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
kumactl install control-plane \
  --tls-api-server-secret=api-server-tls
```
{% endtab %}
{% tab configure-control-plane Kubernetes (HELM) %}
Create a secret in the namespace in which the control plane is installed:
```sh
kubectl create secret tls api-server-tls -n <namespace> \
  --cert=/tmp/tls.crt \
  --key=/tmp/tls.key
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
helm install --create-namespace --namespace <namespace> kuma kuma/kuma \
  --set controlPlane.tls.apiServer.secretName=api-server-tls
```

{% endtab %}
{% tab configure-control-plane Universal %}
Point to the certificate and the key:
```sh
KUMA_API_SERVER_HTTPS_TLS_CERT_FILE=/tmp/tls.crt \
  KUMA_API_SERVER_HTTPS_TLS_KEY_FILE=/tmp/tls.key \
  kuma-cp run
```

{% endtab %}
{% endtabs %}

3) Configure secure connection using `kumactl` CLI tool:
```sh
kumactl config control-planes add \
  --name=<NAME> \
  --address=https://<KUMA_CP_DNS_NAME>:5682 \
  --ca-cert-file=/tmp/ca.crt \
```

We can also hide the HTTP version of API Server by binding it to localhost `KUMA_API_SERVER_HTTP_INTERFACE: 127.0.0.1` or by disabling it altogether `KUMA_API_SERVER_HTTP_ENABLED: false`

### Authentication

See [API Server authentication](/docs/{{ page.version }}/security/api-server-auth/).

## Control plane to control plane (Multizone)

A zone control plane connects to a global control plane for policies configuration.

### Encrypted communication

Because the global control plane and the zone control plane exchange sensitive information, the communication needs to be encrypted by TLS.
By default, the global control plane's server that is consumed by the zone control plane is secured by TLS with autogenerated certificates.

It is recommended that the zone control plane verifies the identity of the global control plane. To do so, zone control planes need to obtain the CA that was used to generate the certificate by which the control plane's server is secured.

**To override autogenerated certificates**

1) Prepare certificates 

Generate TLS pair with a PKI of your choice and store it in PEM-encoded format in `/tmp/tls.crt`, `/tmp/tls.key`. 
Store the CA that was used to sign this pair in `/tmp/ca.crt`

We can also use `kumactl` to generate self-signed certs:
```sh
kumactl generate tls-certificate \
  --type=server \
  --hostname=<CROSS_ZONE_KUMA_CP_DNS_NAME> \
  --cert-file=/tmp/tls.crt \
  --key-file=/tmp/tls.key
```

Since "tls.crt" is a self-signed cert, it is also a CA:
```sh
cp /tmp/tls.crt /tmp/ca.crt
```

2) Configure global control plane
{% tabs global-control-plane useUrlFragment=false %}
{% tab global-control-plane Kubernetes (kumactl) %}
Create a secret in the namespace where the global control plane is installed:
```sh
kubectl create secret tls kds-server-tls -n <namespace> \
  --cert=/tmp/tls.crt \
  --key=/tmp/tls.key
```

Point to this secret when installing the global control plane:
```sh
kumactl install control-plane \
  --mode=global \
  --tls-kds-global-server-secret=general-tls-certs
```
{% endtab %}
{% tab global-control-plane Kubernetes (HELM) %}
Create a secret in the namespace where the global control plane is installed:
```sh
kubectl create secret tls kds-server-tls -n <namespace> \
  --cert=/tmp/tls.crt \
  --key=/tmp/tls.key
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
helm install --create-namespace --namespace <namespace> kuma kuma/kuma \
  --set controlPlane.tls.kdsGlobalServer.secretName=kds-server-tls
```

{% endtab %}
{% tab global-control-plane Universal %}
Point to the certificate and the key: 
```sh
KUMA_MULTIZONE_GLOBAL_KDS_TLS_CERT_FILE=/tmp/tls.crt \
  KUMA_MULTIZONE_GLOBAL_KDS_TLS_KEY_FILE=/tmp/tls.key \
  KUMA_MODE=global \
  kuma-cp run
```
{% endtab %}
{% endtabs %}

3) Configure the zone control plane

{% tabs zone-control-plane useUrlFragment=false %}
{% tab zone-control-plane Kubernetes (kumactl) %}
Create a secret in the namespace where the zone control plane is installed:
```sh
kubectl create secret generic kds-ca-certs -n <namespace> \
  --from-file=ca.crt.pem=/tmp/ca.crt
```

Point to this secret when installing the zone control plane:
```sh
kumactl install control-plane \
  --mode=zone \
  --tls-kds-zone-client-secret=kds-ca-certs
```
{% endtab %}
{% tab zone-control-plane Kubernetes (HELM) %}
Create a secret in the namespace where the zone control plane is installed:
```sh
kubectl create secret generic kds-ca-certs -n <namespace> \
  --from-file=ca.crt.pem=/tmp/ca.crt
```

Point to this secret when installing {{site.mesh_product_name}}:
```sh
helm install --create-namespace --namespace <namespace> kuma kuma/kuma \
  --set controlPlane.tls.kdsZoneClient.secretName=kds-ca-certs
```

{% endtab %}
{% tab zone-control-plane Universal %}
Point to the certificate and the key:
```sh
KUMA_MULTIZONE_ZONE_KDS_ROOT_CA_FILE=/tmp/ca.crt \
  KUMA_MODE=zone \
  KUMA_MULTIZONE_ZONE_GLOBAL_ADDRESS=grpcs://<CROSS_ZONE_KUMA_CP_DNS_NAME>:5685 \
  kuma-cp run
```
{% endtab %}
{% endtabs %}

### Authentication

Define firewall rules on the global control plane to only accept connections from known IPs of the zone control planes.

{% tip %}
Third-party extensions, cloud implementations or [commercial offerings](/enterprise) may be extending the authentication support.
{% endtip %}
