---
#
#  WARNING: this file was auto-generated by a script.
#  DO NOT edit this file directly. Instead, send a pull request to change
#  https://github.com/Kong/kong/tree/master/kong/pdk
#  or its associated files
#
title: kong.log
pdk: true
toc: true
source_url: https://github.com/Kong/kong/tree/master/kong/pdk/log.lua
---

<!-- vale off -->

This namespace contains an instance of a logging facility, which is a
 table containing all of the methods described below.

 This instance is namespaced per plugin. Before
 executing a plugin, Kong swaps this instance with a logging facility
 dedicated to the plugin. This allows the logs to be prefixed with the
 plugin's name for debugging purposes.




## kong.log(...)

Writes a log line to the location specified by the current Nginx
 configuration block's `error_log` directive, with the `notice` level (similar
 to `print()`).

 The Nginx `error_log` directive is set via the `log_level`, `proxy_error_log`
 and `admin_error_log` Kong configuration properties.

 Arguments given to this function are concatenated similarly to
 `ngx.log()`, and the log line reports the Lua file and line number from
 which it was invoked. Unlike `ngx.log()`, this function prefixes error
 messages with `[kong]` instead of `[lua]`.

 Arguments given to this function can be of any type, but table arguments
 are converted to strings via `tostring` (thus potentially calling a
 table's `__tostring` metamethod if set). This behavior differs from
 `ngx.log()` (which only accepts table arguments if they define the
 `__tostring` metamethod) with the intent to simplify its usage and be more
 forgiving and intuitive.

 Produced log lines have the following format when logging is invoked from
 within the core:

 ``` plain
 [kong] %file_src:%line_src %message
 ```

 In comparison, log lines produced by plugins have the following format:

 ``` plain
 [kong] %file_src:%line_src [%namespace] %message
 ```

 Where:

 * `%namespace`: The configured namespace (in this case, the plugin name).
 * `%file_src`: The filename the log was called from.
 * `%line_src`: The line number the log was called from.
 * `%message`: The message, made of concatenated arguments given by the caller.

 For example, the following call:

 ``` lua
 kong.log("hello ", "world")
 ```

 would, within the core, produce a log line similar to:

 ``` plain
 2017/07/09 19:36:25 [notice] 25932#0: *1 [kong] some_file.lua:54 hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```

 If invoked from within a plugin (for example, `key-auth`) it would include the
 namespace prefix:

 ``` plain
 2017/07/09 19:36:25 [notice] 25932#0: *1 [kong] some_file.lua:54 [key-auth] hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Parameters**

* **...** :  All parameters will be concatenated and stringified before being sent to the log.

**Returns**

*  Nothing. Throws an error on invalid inputs.


**Usage**

``` lua
kong.log("hello ", "world") -- alias to kong.log.notice()
```



## kong.log.LEVEL(...)

Similar to `kong.log()`, but the produced log has the severity given by
 `<level>`, instead of `notice`.  The supported levels are:

 * `kong.log.alert()`
 * `kong.log.crit()`
 * `kong.log.err()`
 * `kong.log.warn()`
 * `kong.log.notice()`
 * `kong.log.info()`
 * `kong.log.debug()`

 Logs have the same format as that of `kong.log()`. For
 example, the following call:

 ``` lua
  kong.log.err("hello ", "world")
 ```

 would, within the core, produce a log line similar to:

 ``` plain
 2017/07/09 19:36:25 [error] 25932#0: *1 [kong] some_file.lua:54 hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```

 If invoked from within a plugin (for example, `key-auth`) it would include the
 namespace prefix:

 ``` plain
 2017/07/09 19:36:25 [error] 25932#0: *1 [kong] some_file.lua:54 [key-auth] hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Parameters**

* **...** :  All params will be concatenated and stringified before being sent to the log.

**Returns**

*  Nothing. Throws an error on invalid inputs.


**Usage**

``` lua
kong.log.warn("something require attention")
kong.log.err("something failed: ", err)
kong.log.alert("something requires immediate action")
```



## kong.log.deprecation(...)

Write a deprecation log line (similar to `kong.log.warn`).

 Arguments given to this function can be of any type, but table arguments
 are converted to strings via `tostring` (thus potentially calling a
 table's `__tostring` metamethod if set). When the last argument is a table,
 it is considered as a deprecation metadata. The table can include the
 following properties:

 ``` lua
 {
   after = "2.5.0",   -- deprecated after Kong version 2.5.0 (defaults to `nil`)
   removal = "3.0.0", -- about to be removed with Kong version 3.0.0 (defaults to `nil`)
   trace = true,      -- writes stack trace along with the deprecation message (defaults to `nil`)
 }
 ```

 For example, the following call:

 ``` lua
 kong.log.deprecation("hello ", "world")
 ```

 would, within the core, produce a log line similar to:

 ``` plain
 2017/07/09 19:36:25 [warn] 25932#0: *1 [kong] some_file.lua:54 hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```

 If invoked from within a plugin (for example, `key-auth`) it would include the
 namespace prefix:

 ``` plain
 2017/07/09 19:36:25 [warn] 25932#0: *1 [kong] some_file.lua:54 [key-auth] hello world, client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```

 And with metatable, the following call:

 ``` lua
 kong.log.deprecation("hello ", "world", { after = "2.5.0", removal = "3.0.0" })
 ```

 would, within the core, produce a log line similar to:

 ``` plain
 2017/07/09 19:36:25 [warn] 25932#0: *1 [kong] some_file.lua:54 hello world (deprecated after 2.5.0, scheduled for removal in 3.0.0), client: 127.0.0.1, server: localhost, request: "GET /log HTTP/1.1", host: "localhost"
 ```


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Parameters**

* **...** :  all params will be concatenated and stringified before being sent to the log
            (if the last param is a table, it is considered as a deprecation metadata)

**Returns**

*  Nothing; throws an error on invalid inputs.


**Usage**

``` lua
kong.log.deprecation("hello ", "world")
kong.log.deprecation("hello ", "world", { after = "2.5.0" })
kong.log.deprecation("hello ", "world", { removal = "3.0.0" })
kong.log.deprecation("hello ", "world", { after = "2.5.0", removal = "3.0.0" })
kong.log.deprecation("hello ", "world", { trace = true })
```



## kong.log.inspect(...)

Like `kong.log()`, this function produces a log with a `notice` level
 and accepts any number of arguments.  If inspect logging is disabled
 via `kong.log.inspect.off()`, then this function prints nothing, and is
 aliased to a "NOP" function to save CPU cycles.

 This function differs from `kong.log()` in the sense that arguments will be
 concatenated with a space(`" "`), and each argument is
 pretty-printed:

 * Numbers are printed (e.g. `5` -> `"5"`)
 * Strings are quoted (e.g. `"hi"` -> `'"hi"'`)
 * Array-like tables are rendered (e.g. `{1,2,3}` -> `"{1, 2, 3}"`)
 * Dictionary-like tables are rendered on multiple lines

 This function is intended for debugging, and usage
 in production code paths should be avoided due to the expensive formatting
 operations it can perform. Existing statements can be left in production code
 but nopped by calling `kong.log.inspect.off()`.

 When writing logs, `kong.log.inspect()` always uses its own format, defined
 as:

 ``` plain
 %file_src:%func_name:%line_src %message
 ```

 Where:

 * `%file_src`: The filename the log was called from.
 * `%func_name`: The name of the function the log was called from.
 * `%line_src`: The line number the log was called from.
 * `%message`: The message, made of concatenated, pretty-printed arguments
   given by the caller.

 This function uses the [inspect.lua](https://github.com/kikito/inspect.lua)
 library to pretty-print its arguments.


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Parameters**

* **...** :  Parameters are concatenated with spaces between them and
 rendered as described.

**Usage**

``` lua
kong.log.inspect("some value", a_variable)
```



## kong.log.inspect.on()

Enables inspect logs for this logging facility.  Calls to
 `kong.log.inspect` will be writing log lines with the appropriate
 formatting of arguments.


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Usage**

``` lua
kong.log.inspect.on()
```



## kong.log.inspect.off()

Disables inspect logs for this logging facility.  All calls to
 `kong.log.inspect()` will be nopped.


**Phases**

* init_worker, certificate, rewrite, access, header_filter, response, body_filter, log

**Usage**

``` lua
kong.log.inspect.off()
```



## kong.log.set_serialize_value(key, value, options)

Sets a value to be used on the `serialize` custom table.

 Logging plugins use the output of `kong.log.serialize()` as a base for their logs.
 This function lets you customize the log output.

 It can be used to replace existing values in the output, or to delete
 existing values by passing `nil`.

 **Note:** The type-checking of the `value` parameter can take some time, so
 it is deferred to the `serialize()` call, which happens in the log
 phase in most real-usage cases.


**Phases**

* certificate, rewrite, access, header_filter, response, body_filter, log

**Parameters**

* **key** (`string`):  The name of the field.
* **value** (`number|string|boolean|table`):  Value to be set. When a table is used, its keys must be numbers, strings, or booleans, and its values can be numbers, strings, or other tables like itself, recursively.
* **options** (`table`):  Can contain two entries: options.mode can be `set` (the default, always sets), `add` (only add if entry does not already exist) and `replace` (only change value if it already exists).

**Returns**

* `table`:  The request information table.


**Usage**

``` lua
-- Adds a new value to the serialized table
kong.log.set_serialize_value("my_new_value", 1)
assert(kong.log.serialize().my_new_value == 1)

-- Value can be a table
kong.log.set_serialize_value("my", { new = { value = 2 } })
assert(kong.log.serialize().my.new.value == 2)

-- It is possible to change an existing serialized value
kong.log.set_serialize_value("my_new_value", 3)
assert(kong.log.serialize().my_new_value == 3)

-- Unset an existing value by setting it to nil
kong.log.set_serialize_value("my_new_value", nil)
assert(kong.log.serialize().my_new_value == nil)

-- Dots in the key are interpreted as table accesses
kong.log.set_serialize_value("my.new.value", 4)
assert(kong.log.serialize().my.new_value == 4)
```



## kong.log.serialize()

Generates a table with useful information for logging.

 This method can be used in the `http` subsystem.

 The following fields are included in the returned table:
 * `client_ip` - client IP address in textual format.
 * `latencies` - request/proxy latencies.
 * `request.headers` - request headers.
 * `request.method` - request method.
 * `request.querystring` - request query strings.
 * `request.size` - size of request.
 * `request.url` and `request.uri` - URL and URI of request.
 * `response.headers` - response headers.
 * `response.size` - size of response.
 * `response.status` - response HTTP status code.
 * `route` - route object matched.
 * `service` - service object used.
 * `started_at` - timestamp this request came in, in milliseconds.
 * `tries` - Upstream information; this is an array and if any balancer retries occurred, will contain more than one entry.
 * `upstream_uri` - request URI sent to Upstream.

 The following fields are only present in an authenticated request (with consumer):

 * `authenticated_entity` - credential used for authentication.
 * `consumer` - consumer entity accessing the resource.

 The following fields are only present in a TLS/HTTPS request:
 * `request.tls.version` - TLS/SSL version used by the connection.
 * `request.tls.cipher` - TLS/SSL cipher used by the connection.
 * `request.tls.client_verify` - mTLS validation result. Contents are the same as described in [$ssl_client_verify](https://nginx.org/en/docs/http/ngx_http_ssl_module.html#var_ssl_client_verify).
 {% if_version gte:3.5.x %}

 The following field is only present in requests where a tracing plugin (OpenTelemetry or Zipkin) is executed:
 * `trace_id` - trace ID.

 The following field is only present in requests where the Correlation ID plugin is executed:
 * `correlation_id` - correlation ID.
 {% endif_version %}

 **Warning:** This function may return sensitive data (e.g., API keys).
 Consider filtering before writing it to unsecured locations.

 All fields in the returned table may be altered using `kong.log.set_serialize_value`.

 The following HTTP authentication headers are redacted by default, if they appear in the request:
 * `request.headers.authorization`
 * `request.headers.proxy-authorization`

 To see what content is present in your setup, enable any of the logging
 plugins (e.g., `file-log`) and the output written to the log file is the table
 returned by this function JSON-encoded.


**Phases**

* log

**Returns**

* `table`:  the request information table


**Usage**

``` lua
kong.log.serialize()
```
